# JVM
### 可达性分析

GC Root为根节点，开始向下搜索，如果从GC Root到某个对象不可达，则证明此对象是不会在被使用的。

垃圾回收线程运行的同时，其他线程也是在运行的，如何准确的将可回收线程标记出来。简单粗暴的方式就是将其他线程全部暂停直到垃圾收集结束(Stop The World)。这种方式在单核(没有线程切换消耗，专心收垃圾)，管理内存小(对象引用图不复杂，查找引用链时间短)时还行。如果堆越大，存储对象越多，对象结构图越复杂，标记产生停顿时间越长。怎么做才能尽可能减少停顿时间呢。

##### 三色标记算法

白色：尚未被垃圾收集器扫描。开始阶段都是白色。扫描结束仍为白色说明该对象不可达

灰色：该对象已经被垃圾收集器扫描，但最少还有一个引用没被扫描过

黑色：该对象所有引用都已经扫描过，无需重新扫描。黑色对象不可能直接指向某个白色对象(不经过灰色对象)

![](https://raw.githubusercontent.com/yongsongTang/PicGo/main/img/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%20(2).png)

1. 初始标记

   > 将GC Root能直接关联的对象标记为灰色。Stop The World
   >
   > 根节点枚举必须在一个能保障一致性的快照中进行，整个枚举期间执行子系统看起来就像是被冻结在某个时间点上。如果不停下来，所有分析都是基于一个不准确的引用关系

2. 并发标记

   > 从灰色对象开始遍历对象图，(只是这一层，广度优先)将灰色对象直接关联的对象标记为灰色。如果该对象所有引用都扫描完成，则将该对象标记为黑色
   >
   > > | 应该 | 实际 | 原因                                                         |                            |
   > > | :--: | ---- | ------------------------------------------------------------ | -------------------------- |
   > > | 白色 | 黑色 | 在标记为灰色之后引用链断裂                                   | 能接受,等待下一次扫描      |
   > > | 黑色 | 白色 | 以下两条件同时满足时会出现对象消失[^1]<br />1. 插入一条或多条从黑色对象到白色对象新引用<br />2. 删除了全部从灰色对象到该白色对象的引用 | 对象消失，回收使用中的内存 |

3. 重新标记

   > 由于并发标记阶段，对象间引用关系发生变化。确保在并发标记期间发生的引用关系变化被正确处理。Stop The World 
   >
   > > 1. 增量更新，黑色对象插入新的指向白色对象引用关系时，将新插入的引用记录下来。并发扫描结束后，将记录中的黑色对象为根，重新扫描一次。黑色对象一旦插入白色对象就变回灰色对象了。
   > > 2. 原始快照，灰色对象要删除指向白色对象引用关系时，将这个要删除引用记录下来。并发扫描结束后，将记录过的引用中的灰色对象为根，重新扫描一次。无论引用关系是否删除，都会按照刚开始那一刻的对象图快照进行扫描。







[^1]: 深入理解Java虚拟机-周志明
