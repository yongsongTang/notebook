# cpp对象内存布局

一个对象在内存中排列方式

## 对齐规则

**内存对齐：** 数据在内存中的存储地址必须是某个值的整数倍。以提高CPU访问内存的效率。比如，cpu一次性读取4字节，一个int类型的数据如果存储在`0x00-0x03`的位置一次读完了，如果存储在`0x01-0x04`位置，需要读取两次，一次读`0x00-0x03`，一次读`0x04-0x07`然后组合`0x01-0x04`的数据。

### 基本数据类型

| 类型   | 长度                | 对齐要求                |
| ------ | ------------------- | ----------------------- |
| char   | 1字节               | 1字节                   |
| short  | 2字节               | 2字节                   |
| int    | 4字节               | 4字节                   |
| float  | 4字节               | 4字节                   |
| long   | 4(32位)/8(64位)字节 | 4(32位)/(64位)字节对齐  |
| double | 8字节               | 8字节对齐               |
| void*  | 4(32位)/8(64位)字节 | 4(32位)/8(64位)字节对齐 |

char 占用1个字节，1字节对齐，那么char类型数据可以出现在任何内存地址处。int 占用4字节内存，4字节对齐，那么int类型的数据只能出现地址为4的整数倍位置处。

### 结构体或者类

- 按照变量声明顺序依次类型对齐。
- 结构体或者类，总的大小是其成员变量中最大的对齐要求。

```cpp
class Base {
    short s_short = 99; //2字节，第0-1字节
    const char *s_pc = "8 or 4"; // 8字节(字节对齐)，第8-15字节，第2-7字节填充
    char s_c = 'a'; // 1字节
}; // 2 + [6] + 8 + 1 = 17 +[7] = 24 总大小安装成员变量中最大的对齐要求，8字节对齐，所以末尾填充7字节
```

Base对象内存排布方式，2字节(0-1)存储`short`变量，`char *`8字节对齐，只能出现在地址为8的位置，所以填充6字节(2-7)，第8-15字节存储`char *`变量，第16字节存储`char`。现在类总大小2+6+8+1=17字节，按照成员变量中最大的对齐方式(来自`char *`的8字节)对齐，所以填充7字节。总大小17+7=24字节

| 字节偏移 | 0-1     | 2-7  | 8-15 | 16  | 17-23 |
| -------- | ------- | ---- | ---- | --- | ----- |
| 变量     | s_short | 填充 | s_pc | s_c | 填充  |

```cpp
    printf("%lu\n", sizeof(Base)); // 24
    Base b;
    uint64_t base = (uint64_t) &b;
    // 第16字节位置 存储chard s_c变量
    base += 16;
    auto base_c = (char *) base;
    printf("c: %c\n", *base_c); // a
```

## 类中包含方法

```cpp
class Base {
    short s_short = 99; //2字节
    const char *s_pc = "8 or 4"; // 64位机器8字节
    char s_c = 'a'; // 1字节

    // 静态变量，类的属性，所有对象共享 存储在数据段  ==> 不占用对象内存空间
    static int s_static;

    // 非虚方法，所有对象共享，存储在代码段 ==> 不占用对象内存空间
    void dump() { printf("Base %s %d %s %c\n", __func__, s_short, s_pc, s_c); }

    // 虚方法，对象开始位置增加一指针，指向虚函数表(vtable)。虚函数表是个函数指针数组
    // 虚函数表存储在只读数据段(或代码段取决于编译器)，每个虚函数在表中有一条记录
    virtual void virtual_f() { printf("Base %s\n", __func__); };
}; // 8 + 2 + [6] + 8 + 1 = 25 +[7] = 32
```

### 非虚方法

非虚成员方法，所有对象共享的，只有一份存储在代码段。静态成员变量，类的属性，所有对共享，存储在数据段。此时对象占用内存大小并没有改变。

### 虚方法

类中存在虚方法(包括虚析构函数)，对象内存的开始位置增加一指针，指向虚函数表(vtable)。虚函数表是个函数指针数组。此时对象开始位置增加了8字节(64位)存储执行虚函数表的指针。

```cpp
    printf("%zu \n", sizeof(Base));  // 32
    Base b;
    auto base = (uint64_t) &b;
    // 虚函数
    void ***p_vtable = (void ***) base;
    void **vtable = *p_vtable; // 虚函数表
    // 第0个虚函数 调用
    using Type_fun = void (*)();
    auto f = (Type_fun) vtable[0];
    f(); // 虚函数virtual_f方法被调用
    
    // 第16字节位置 存储char* s_pc变量
    base += 16;
    auto base_spc = (char **) base;
    printf("c: %s\n", *base_spc); // "8 or 4"
```

| 字节偏移  | 0-7 | 8-9  | 10-15  | 16-23 | 24  | 25-31 |
| -------- | ---- | ---- | ---- | --- | ---- | ---- |
| 变量     | p_vtable 指向vtable | s_short | 填充 | s_pc | s_c | 填充  |

第0-7字节存储指向虚函数表的指针。下一个s_short变量2字节对齐，从第8位置开始不用填充， 第8-9字节存储s_short。下一个s_pc变量8字节对齐，得从第16字节开始存储，所以填充6字节(10-15)，从第16字节开始后的8字节(16-23)存储s_pc。第24字节存储s_c。此时共25字节，按照类的最大成员变量对齐(8字节)，填充7字节(25-31)。

## 类中有继承关系

```cpp
class Base {
public:
    short s_short = 99; //2字节
    const char *s_pc = "8 or 4"; // 64位机器8字节
    virtual void virtual_f() { printf("Base %s\n", __func__); }  // 8

    virtual void virtual_f1() { printf("Base %s\n", __func__); }  // 8
}; // 8(指向虚函数表的指针) + 2(s_short) + [6](填充) + 8(s_pc) = 24

class Child : private Base {
public:
    bool c_b = false;
    // 子类和基类 同名成员变量 ok
    short s_short = 212;

    void virtual_f() override { printf("child %s\n", __func__); }
};// 24(基类) + 1(c_b) + [1](填充) + 2(s_short) = 28 +[4](填充) = 32
```

Base基类内存布局

| 字节偏移  | 0-7 |  8-9  | 10-15  | 16-23 |
| -------- | ---- | ---- | ---- | ---- |
| 变量     | 指向虚函数表的指针 | s_short | 填充 | s_pc |

Child扩展类对象内存布局

| 字节偏移  | 0-23 | 24  | 25  | 26-27 | 28-31  |
| -------- | ---- | ---- | ---- | --- | ---- |
| 变量     | Base基类 | c_b | 填充 | s_short | 填充 |

每个有虚函数的*类*(Base，Child)有自己的虚函数表，所有对象共享虚函数表，调用类非静态方法时隐式传入指向类对象的this指针。没有复写基类虚方法时，子类和基类虚函数表内容相同(只是内容相同，子/基类有自己的虚函数表)，复写了某个虚方法时，修改对应虚函数表指向对应方法。

> - 不同编译器内存布局可能不一样
> - 虚函数表的前一个指针既`void **vtable = *(void ***) &c; auto *pTypeInfo = static_cast<std::type_info *>(vtable[-1]);
`，指向的是`std::type_info*`，如果有虚函数并且编译时没有禁用`-fno-rtti`的话。

> 同一个地址既可以转成 void *** 又可以转成Bean*

## 内存段

### 运行时内存段

运行时将虚拟内存按照逻辑功能分为一段一段的，以方便管理。比如：代码段(.text)存放编译后方法的二进制指令，只读防止代码注入。编译后的可执行文件，动态，静态库也是分段存储的(文件内存段)，在运行时按照分段加载到内存中。静态库在连接时，将代码、变量合并到可执行文件。动态库则是在运行时独立隐射(mmap)到内存中，所有进程共享，通过plt，got机制访问。

| 地址  | 段 |  名称  | 存储数据  | 权限 | 说明 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 0x0  |    |       |          |    |  程序头，系统信息  |
|0x0000555555555020-0x0000555555555050|.plt | 过程连接表 | 每个被引用动态库方法生成的一小段代码 | 读、执行 |  |
|0x0000555555555060-0x00005555555551b6|.text| 代码段 | 方法(全局方法 类方法)编译后可执行的二进制指令 | 读、执行 | 共享库的代码段被多个进程共享 |
|0x0000555555556000-0x000055555555601e|.rodata| 只读数据| 常量()，虚函数表，类信息 | 读 | |
|0x0000555555557fb8-0x0000555555557fe8|.got|全局偏移表|保存动态库中全局变量的地址| 读、写| |
|0x0000555555557fe8-0x0000555555558010|.got.plt| | 指针方法数组，每个元素都是指针，指向动态库中方法| 读、写| |
|0x0000555555558010-0x0000555555558020|.data|数据段| 初始化的全局变量，静态变量(包括类静态变量) | 读、写| |
|0x0000555555558020-0x0000555555558028|.bss| | 未初始化的全局变量，静态变量(包括类静态变量) |读、写| 加载时初始化为0，代码初始化全0的，编译器可能优化到bss段 |
|0x00005d537722b000-0x00005d53775f6000|.heap| 堆 | 动态分配的内存，手动管理 | 读、写 | 可能产生内存碎片 |
|0x00007ffff7fc52a8-0x00007ffff7a11d90|.mmp|映射|动态库，文件，匿名映射| 多个权限 | 每个共享库独立分段，映射到这一区域 |
|0x00007ffc11ad4000-0x00007ffc11afc000|.stack|栈 | 线程栈，局部变量，自动管理 | 读、写 |  |

> 中间缺了很多分段，真实分段更多更详细。可以在gdb下用`info file`查看运行时各个段及其地址。或者`cat /proc/{pid}/maps`看运行时地址。

类的非静态变量(成员变量)，在堆或者栈上，取决于类是怎么创建的。

#### 栈上对象创建

栈上分配对象所需的内存(rsp指针移动)，调用对象构造函数，构造函数中设置初始化的成员变量的值。没初始化的成员变量没有设置值(ied会警告)

```cpp
class Bean {
public:
    int class_val = 90;  
    long class_val_un_init; //
};  // 4 + [4] +8 = 16
```

```cpp
void test_fun() {
    Bean a;
}
```

```shell
    #  Bean a;  test_fun()方法对应的汇编
    1184:       48 83 ec 10             sub    $0x10,%rsp   # 栈上内存分配。这里只有Bean变量，所有其实是为Bean对象分配内存
    1188:       48 8d 7d f0             lea    -0x10(%rbp),%rdi # 刚刚分配内存的首地址(this指针) 赋值给rdi
    118c:       e8 0f 00 00 00          call   11a0 <_ZN4BeanC2Ev> # 直接调用构造函数
    1191:       48 83 c4 10             add    $0x10,%rsp # 回收栈上内存

    # 构造方法
0000000000001190 <_ZN4BeanC2Ev>:
    1194:       48 89 7d f8             mov    %rdi,-0x8(%rbp) # this指针（构造方法传了this指针，类方法调用第一个参数都会传this）
    1198:       48 8b 45 f8             mov    -0x8(%rbp),%rax # 类成员变量class_val地址，-0x8(%rbp)倒过来存储
    119c:       c7 00 5a 00 00 00       movl   $0x5a,(%rax) # 初始化了的成员变量， class_val=90， 注意：没初始化的成员变量没有设置值
```

#### 堆上对象创建

##### 值初始化

`new Bean()`

1. new操作符operator new(size_t)创建内存。
2. 值初始还。
    2.1 没有自定义构造函数，先0初始化(memset置0)，再调用构造函数设置成员变量默认值。
    2.2 有自定义构造函数，调用构造方法，设置有值的成员变量。这种情况下，没有预先的 memset 清零操作，定义了构造函数，就由构造函数完成所有初始化操作。

```cpp
void test_fun() {
    Bean *p = new Bean(); // 1. new操作符 2. 没有定义构造函数，先0初始化(memset)，在设置变量默认值。定义了构造函数，设置变量默认值。没有0初始化操作
    // 聚合类 指定初始化
    // Bean *p = new Bean{.class_val_un_init=9}; // 1.new操作符 2.根据列表初始化对应值，列表中没提到的成员变了，值初始化(有默认值默认值，没有默认值0)
}
```

```shell
    # Bean *p = new Bean(); test_fun()方法对应的汇编
    11a4:       48 83 ec 10             sub    $0x10,%rsp  # 栈上内存分配，只有一个指针变量(Bean *p)，但是分配的是16字节
    11a8:       bf 10 00 00 00          mov    $0x10,%edi  # new 操作符参数
    11ad:       e8 9e fe ff ff          call   1050 <_Znwm@plt> # new操作符， operator new(size_t)
    11b2:       48 89 c7                mov    %rax,%rdi # new操作结束地址 存在rax寄存器，
    11b5:       48 89 7d f0             mov    %rdi,-0x10(%rbp) # new返回的地址 存在栈-0x10(%rbp)位置，指针变量p
    11b9:       31 f6                   xor    %esi,%esi  # 0 同一个数xor  memset参数
    11bb:       ba 10 00 00 00          mov    $0x10,%edx # memset参数
    11c0:       e8 7b fe ff ff          call   1040 <memset@plt> # new的内存全部设置成0
    11c5:       48 8b 7d f0             mov    -0x10(%rbp),%rdi  # 对象指针this，作为构造函数的参数
    11c9:       e8 12 00 00 00          call   11e0 <_ZN4BeanC2Ev> # 调用构造方法

    # 构造方法
00000000000011e0 <_ZN4BeanC2Ev>:
    11e4:       48 89 7d f8             mov    %rdi,-0x8(%rbp) # this(对象起指针)
    11e8:       48 8b 45 f8             mov    -0x8(%rbp),%rax # 类成员变量class_val地址
    11ec:       c7 00 5a 00 00 00       movl   $0x5a,(%rax) # 初始化了的成员变量， class_val=90
```

##### 指定初始化(聚合初始化)

`new Bean{.class_val_un_init=9}`。只能用于聚合类。

1. 调用new操作符operator new(size_t)创建内存。
2. 根据列表`{}`值设置对应成员变量值。列表中有值使用列表中的值，列表中没有提到的值，使用值初始化(有默认值设置为默认值，没有默认值设置未0)。

```shell
    # 聚合类列表创建 Bean *p = new Bean{.class_val = 92,}; test_fun()方法对应的汇编
    1194:       48 83 ec 10             sub    $0x10,%rsp # 栈上内存分配，只有一个指针变量(Bean *p)，但是分配的是16字节
    1198:       bf 10 00 00 00          mov    $0x10,%edi # new 操作符参数 
    119d:       e8 9e fe ff ff          call   1040 <_Znwm@plt> # new操作符， operator new(size_t)
    11a2:       c7 00 5a 00 00 00       movl   $0x5a,(%rax) # 始化列表中没有对应值，使用成员初始化的值，（没有初始化值，设置0）
    11a8:       48 c7 40 08 09 00 00    movq   $0x9,0x8(%rax) # 用初始化列表中的对应参数赋值
```

**代码段：** 存储编译后方法的二进制执行。在编译后方法的地址就确定了，有两种情况，相对地址(位置无关)和绝对地址(位置无关)。

1. 位置有关代码，编译后方法地址，就是运行时方法量地址，代码段必须加载到指定内存位置。
2. 位置无关代码(PIC)，编译后方法地址是基于代码段地址的偏移量。代码段可以加载到任意内存位置。

> - 位置无关代码(PIC)，运行时相对地址计算，所以比绝对地址，直接调用要慢一点(忽略不计)，但是可以防止内存攻击。默认编译为位置无关代码(PIC)。
> - 动态库是运行时映射到内存中，编译时还不知道地址，每个进程共享映射到不同的内存位置。所以动态库是没法编译成位置相关代码的。

调用非虚方法时，通过绝对地址或者相对地址(代码段基地址+偏移量)，找到对应方法。调用虚方法时，先访问对象的虚函数表，在通过虚函数表找到对应方法。

**数据段：** 存储初始化的全局变量，静态变量。记录变量，类型，初始值。初始值可能非常大，比如：`int arr[1024 * 1024 * 10] = {9, 4, 2};` 40M，意味着数据段只少要存储40M的数据，可执文件大小40M起。在运行加载时，分配内存读取变量值赋值给变量。

```shell
# 初始化的全局变量 int arr[1024 * 1024 * 10] = {9, 4, 2 };
➜ size main_seg                    
   text    data     bss     dec     hex filename
    173 41943048              0 41943221        28000b5 main_seg

➜ ls -lh main_seg
-rwxr-xr-x@ 1 tys  staff    40M Nov 25 19:34 main_seg
```

**bss段：** 存储未初始化的全局变量，静态变量。记录变量，类型，大小。由于只是记录大小，没有实际初始值，可执行文件小了。在运行加载时，分配内存变量值设置为0。

```shell
# 未初始化的全局变量 int arr[1024 * 1024 * 10];
➜ size main_seg                    
   text    data     bss     dec     hex filename
    173       8 41943040        41943221        28000b5 main_seg

➜ ls -lh main_seg
-rwxr-xr-x@ 1 tys  staff   8.3K Nov 25 19:43 main_seg
```

**堆：** 动态分配的内存，手动管理。所有线程共享(除线程本地变量) new/delete malloc/free，分配释放不同大小内存，可能造成内存碎片化。

**映射区：** 内存映射(mmap)，动态库，文件，匿名映射。缺页中断加载数据(访问到未加载的页时，从磁盘加载数据)，多个进程共享同一个物理页。映射的每个动态库，有自己独立的段。

**栈：** 线程栈，自动管理。每个线程自己独立的栈空间(8M)，生命周期固定，过深的递归调用造成栈溢出。存储局部变量，方法参数，返回地址。

```shell
# 栈空间大小查看
➜ ulimit -s
8192
```

**堆，栈对比：**

- 生命周期：栈，随线程的创建而创建，线程退出而结束。堆，需要手动创建和回收。
- 作用范围：栈，每个线程独立的。堆，线程之间共享，多线程之间竞争需要加锁。
- 大小：栈，单个栈大小固定，每个线程都预留8M虚拟空间，所有加起来才是总栈大小。堆，非常大，和虚拟地址空间大小相关。
- 内存创建回收：栈，栈中内存空间的创建和回收只是栈指针的移动，速度非常快。堆，堆中空间的创建回收，涉及系统调用内存管理(查找合适大小的内存空间，碎片的整理合并)。
- 读写速度：栈，内存分配通常连续的，更容易被cpu缓存命中。堆，访问是不确定的，可能导致更多缓存未命中。

> cpu缓存命中：cpu并不是每次从内存中读取它需要的字节数，而是按缓存行大小读取(64k)。如果要访问的数据在缓存行中，就不需要从内存中在读取数据。cpu缓存命中比从内存中加载快得多。缓存行是CPU与内存之间数据传输的基本单位。

### 栈上内存分配

通过栈指针rsp(Register Stack Pointer)的移动，在栈上创建回收空间。

RSP(Register Stack Pointer)寄存器：栈顶指针(始终指向栈顶)，x86架构栈顶(最后放入数据位置)是低地址。随着入栈(push)自动减小，出栈(pop)自动增加。
RBP(Register Base Pointer)寄存器：帧指针，指向函数栈帧基地址。通过偏移访问参数，局部变量。

```cpp
void test_fun(int i, const char *string) {
    // 参数
    // 4 +[4] + 8 = 16
    // 局部变量
    // 16 + 1 = 17 + [15] = 32 // 最终栈16字节对齐
    bool f = true;
    printf("%d \n", i);
}
```

```shell
    ## test_fun方法对应汇编代码 x86架构
    pushq   %rbp    ## 当前方法栈基地址 入栈，rsp自动-8
    movq    %rsp, %rbp  ##  rbp = rsp，rbp指向新的栈基地址
    subq    $32, %rsp   ## rsp -= 32 栈上分配32字节
    movl    %edi, -4(%rbp) ## 第一个int参数存在 -4(%rbp) rbp-4的位置 
    movq    %rsi, -16(%rbp) ## 第二个指针参数存在 -16(%rbp)，依次顺序存储的话应该是-12(%rbp)，所以这里填充了4字节
    movb    $1, -17(%rbp) ## 局部变量 1写入-17(%rbp)
    ...
    addq    $32, %rsp   ## rsp +=32 栈上内存回收
    popq    %rbp    ## 出栈
    retq
```

进入方法后，通过栈指针(rsp)的移动，在栈上分配空间。存储方法参数和局部变量到分配的空间上。

## 库

### 静态库

链接时：

1. 合并静态库的段，到可执行文件对应段。已cpp文件为单位，合并用到的数据，代码。而不是整个静态库。比如：引用了静态代码库中的方法，该方法所在cpp文件，生成的代码、数据段合并到目标文件的代码、数据段。*可以通过编译参数设置，只合并引用到的方法到可执行文件。*
2. 符号解析和重定位。比如，引用静态库中的方法/变量，编译时不知道地址，只是一个占位符。在合并到可执行文件后知道了方法的地址，会将原来占位符的地址填上实际地址。

引用的代码和数据被合并到了可执行文件，所以可执行文件会变大。但是不用指定运行时环境，同时可能有更多的方法内联。

运行时：
应为是合并到可执行文件，所以引用静态库中的方法、变量和引用本地方法、变量是一样的。编译时已经知道方法，变量的地址(偏移量)，运行时通过基地址 + 偏移量找到对应方法，变量。

```shell
#objdump 看调用静态库中方法  objdump main -d
0000000000001140 <main>:
    # main方法中调用静态库中方法，调用的时候直接就是call 地址了(相对或者绝对地址)
    1159:       e8 1c 00 00 00          call   117a <_Z12test_lib_addii> # 已经知道地址了，117a(可执行文件中的偏移) 
    # test_lib_add 方法
000000000000117a <_Z12test_lib_addii>:
    ...
    # 代码段开始地址1050
Disassembly of section .text:
0000000000001050 <_start>:
```

文件中，`test_lib_add`方法，相对代码段的偏移 0x117a-0x1050=0x12a

```shell
#gdb 运行时， 查看段地址
(gdb) info files
0x0000555555555050 - 0x0000555555555192 is .text # 运行时代码段地址
(gdb) info address test_lib_add
Symbol "test_lib_add" is at 0x55555555517a in a file compiled without debugging.
(gdb) x/a 0x55555555517A
0x55555555517a <_Z12test_lib_addii>: 0xe5894855fa1e0ff3 # 0x55555555517a地址处 是test_lib_add方法，方法内容是0xe5894855fa1e0ff3
```

运行时，代码段(.text)基地址 + 方法相对代码段基地址的偏移 = 等于运行时`test_lib_add`方法地址。既 0x0000555555555050 + 0x12a = 0x55555555517A

### 动态库

动态库编译时，知道的是相对于动态库的偏移，每个动态库独立映射在内存中，并且每次映射在不同的内存地址。所以在编译链接时，不知道来自动态库中方法或者变量的地址。也就没办法像静态库一样，直接call目标地址。

**.got：** 全局偏移表(Global Offset Table)，存储全局变量的地址，如果引用了来自动态库中的全局变量，全局变量的地址存储在这里。
**.got.plt：** 方法指针数组。数组中每个元素的是指针，指向来自动态库的方法。只有调用到的方法才会被记录，并不是动态库中的所有方法都会在可执行文件中记录。
**.plt：** 过程链接表(Procedure Linkage Table)，为每个调用动态库中方法，生成的一小段代码(只读)。每次调用动态库中的方法时，都先执行这一小段代码plt[n]。这小段代码写的是，跳转到`.got.plt[n]`提供的地址处执行，第一次提供的地址是连接器，由链接器解析出地址并且回填到`.got.plt[n]`这里，下次调用就是方法的真正地址了。

链接时：

1. 生成got，got.plt,plt表。
2. 识别来自动态库中的符号，并且确认动态库中有声明。当然他不会复制动态库中的代码到可执行文件，记录下依赖这个动态库(运行时指定动态库路径`LD_LIBRARY_PATH`)。

```shell
## objdump -d main
0000000000001160 <main>:
    # 引用来so库的变量
    116f:       48 8d 3d 8e 0e 00 00    lea    0xe8e(%rip),%rdi        # 2004 <_IO_stdin_used+0x4>
    # 调用来so库的方法 
    1178:       e8 b3 fe ff ff          call   1030 <printf@plt>
    ...
    119c:       e8 9f fe ff ff          call   1040 <_Z12test_lib_addii@plt>
# .plt段
Disassembly of section .plt:

# plt[0], 3ff0 3ff8 是连接器的参数和代码 
0000000000001020 <printf@plt-0x10>:
    1020:       ff 35 ca 2f 00 00       push   0x2fca(%rip)        # 3ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:       ff 25 cc 2f 00 00       jmp    *0x2fcc(%rip)        # 3ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:       0f 1f 40 00             nopl   0x0(%rax)
# plt[1], 4000 是 got.plt[1]，第一次存的是1036(printf@plt+6)，控制权交给plt[0]。后续在调用指向方法的真实地址
0000000000001030 <printf@plt>:
    1030:       ff 25 ca 2f 00 00       jmp    *0x2fca(%rip)        # 4000 <printf@GLIBC_2.2.5>
    1036:       68 00 00 00 00          push   $0x0
    103b:       e9 e0 ff ff ff          jmp    1020 <_init+0x20>
# plt[2],
0000000000001040 <_Z12test_lib_addii@plt>:
    1040:       ff 25 c2 2f 00 00       jmp    *0x2fc2(%rip)        # 4008 <_Z12test_lib_addii@Base>
    1046:       68 01 00 00 00          push   $0x1
    104b:       e9 d0 ff ff ff          jmp    1020 <_init+0x20>
```

### gdb调试

main方法中调用test_lib_add方法，到 1040 <_Z12test_lib_addii@plt>，取4008地址的内容出来jump。4008地址出内容是1046(静态，没运行时)，1046处设置参数，连接器解析。

4008对应运行时地址，

文件(静态)，4008地址相对`.got.plt`段开始位置偏移，0x4008 - 0x3fe8 = 0x20
运行时`.got.plt`段开始地址，0x0000555555557fe8 - 0x0000555555558010 is .got.plt
运行时4008(_Z12test_lib_addii@got.plt)地址，0x0000555555557fe8 + 0x20 = 0x555555558008

```shell
# 查看可执行文件 .got.plt段内容
objdump -s -j .got.plt  main    # 不知道4000在那个段的话，可以先readelf 查看4000地址位于那个段

main：     文件格式 elf64-x86-64

Contents of section .got.plt:
 3fe8 983d0000 00000000 00000000 00000000  .=..............
 3ff8 00000000 00000000 36100000 00000000  ........6.......
 4008 46100000 00000000  # 4008 初始值1046，调用_Z12test_lib_addii方法时，引到连接器
```

```shell
# gdb 查看运行时 各个段地址  info file
(gdb) info file
0x0000555555557fe8 - 0x0000555555558010 is .got.plt
# _Z12test_lib_addii 执行前查看 Z12test_lib_addii@got.plt地址，_Z12test_lib_addii@plt+6()，也就是到连接器的地址
(gdb) x/a 0x555555558008
0x555555558008 <_Z12test_lib_addii@got.plt>:	0x555555555046 <_Z12test_lib_addii@plt+6>
... 
# 执行后再次查看Z12test_lib_addii@got.plt地址，指向了动态库映射和方法的真实地址
(gdb) x/a 0x555555558008
0x555555558008 <_Z12test_lib_addii@got.plt>:	0x7ffff7fb90f9 <_Z12test_lib_addii>
```
