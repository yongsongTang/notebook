# cpp对象内存布局

一个对象在内存中排列方式

## 对齐规则

**内存对齐：** 数据在内存中的存储地址必须是某个值的整数倍。以提高CPU访问内存的效率。比如，cpu一次性读取4字节，一个int类型的数据如果存储在`0x00-0x03`的位置一次读完了，如果存储在`0x01-0x04`位置，需要读取两次，一次读`0x00-0x03`，一次读`0x04-0x07`然后组合`0x01-0x04`的数据。

### 基本数据类型


| 类型   | 长度                | 对齐要求                |
| ------ | ------------------- | ----------------------- |
| char   | 1字节               | 1字节                   |
| short  | 2字节               | 2字节                   |
| int    | 4字节               | 4字节                   |
| float  | 4字节               | 4字节                   |
| long   | 4(32位)/8(64位)字节 | 4(32位)/(64位)字节对齐  |
| double | 8字节               | 8字节对齐               |
| void*  | 4(32位)/8(64位)字节 | 4(32位)/8(64位)字节对齐 |

char 占用1个字节，1字节对齐，那么char类型数据可以出现在任何内存地址处。int 占用4字节内存，4字节对齐，那么int类型的数据只能出现地址为4的整数倍位置处。

### 结构体或者类

- 按照变量声明顺序依次类型对齐。
- 结构体或者类，总的大小是其成员变量中最大的对齐要求。

```cpp
class Base {
    short s_short = 99; //2字节，第0-1字节
    const char *s_pc = "8 or 4"; // 8字节(字节对齐)，第8-15字节，第2-7字节填充
    char s_c = 'a'; // 1字节
}; // 2 + [6] + 8 + 1 = 17 +[7] = 24 总大小安装成员变量中最大的对齐要求，8字节对齐，所以末尾填充7字节
```

Base对象内存排布方式，2字节(0-1)存储`short`变量，`char *`8字节对齐，只能出现在地址为8的位置，所以填充6字节(2-7)，第8-15字节存储`char *`变量，第16字节存储`char`。现在类总大小2+6+8+1=17字节，按照成员变量中最大的对齐方式(来自`char *`的8字节)对齐，所以填充7字节。总大小17+7=24字节

| 字节偏移 | 0-1     | 2-7  | 8-15 | 16  | 17-23 |
| -------- | ------- | ---- | ---- | --- | ----- |
| 变量     | s_short | 填充 | s_pc | s_c | 填充  |

```cpp
    printf("%lu\n", sizeof(Base)); // 24
    Base b;
    uint64_t base = (uint64_t) &b;
    // 第16字节位置 存储chard s_c变量
    base += 16;
    auto base_c = (char *) base;
    printf("c: %c\n", *base_c); // a
```

## 类中包含方法

```cpp
class Base {
    short s_short = 99; //2字节
    const char *s_pc = "8 or 4"; // 64位机器8字节
    char s_c = 'a'; // 1字节

    // 静态变量，类的属性，所有对象共享 存储在数据段  ==> 不占用对象内存空间
    static int s_static;

    // 非虚方法，所有对象共享，存储在代码段 ==> 不占用对象内存空间
    void dump() { printf("Base %s %d %s %c\n", __func__, s_short, s_pc, s_c); }

    // 虚方法，对象开始位置增加一指针，指向虚函数表(vtable)。虚函数表是个函数指针数组
    // 虚函数表存储在只读数据段(或代码段取决于编译器)，每个虚函数在表中有一条记录
    virtual void virtual_f() { printf("Base %s\n", __func__); };
}; // 8 + 2 + [6] + 8 + 1 = 25 +[7] = 32
```

### 非虚方法 

非虚成员方法，所有对象共享的，只有一份存储在代码段。静态成员变量，类的属性，所有对共享，存储在数据段。此时对象占用内存大小并没有改变。

### 虚方法

类中存在虚方法(包括虚析构函数)，对象内存的开始位置增加一指针，指向虚函数表(vtable)。虚函数表是个函数指针数组。此时对象开始位置增加了8字节(64位)存储执行虚函数表的指针。

```cpp
    printf("%zu \n", sizeof(Base));  // 32
    Base b;
    auto base = (uint64_t) &b;
    // 虚函数
    void ***p_vtable = (void ***) base;
    void **vtable = *p_vtable; // 虚函数表
    // 第0个虚函数 调用
    using Type_fun = void (*)();
    auto f = (Type_fun) vtable[0];
    f(); // 虚函数virtual_f方法被调用
    
    // 第16字节位置 存储char* s_pc变量
    base += 16;
    auto base_spc = (char **) base;
    printf("c: %s\n", *base_spc); // "8 or 4"
```

| 字节偏移  | 0-7 | 8-9  | 10-15  | 16-23 | 24  | 25-31 |
| -------- | ---- | ---- | ---- | --- | ---- | ---- |
| 变量     | p_vtable 指向vtable | s_short | 填充 | s_pc | s_c | 填充  |

第0-7字节存储指向虚函数表的指针。下一个s_short变量2字节对齐，从第8位置开始不用填充， 第8-9字节存储s_short。下一个s_pc变量8字节对齐，得从第16字节开始存储，所以填充6字节(10-15)，从第16字节开始后的8字节(16-23)存储s_pc。第24字节存储s_c。此时共25字节，按照类的最大成员变量对齐(8字节)，填充7字节(25-31)。

## 类中有继承关系

```cpp
class Base {
public:
    short s_short = 99; //2字节
    const char *s_pc = "8 or 4"; // 64位机器8字节
    virtual void virtual_f() { printf("Base %s\n", __func__); }  // 8

    virtual void virtual_f1() { printf("Base %s\n", __func__); }  // 8
}; // 8(指向虚函数表的指针) + 2(s_short) + [6](填充) + 8(s_pc) = 24

class Child : private Base {
public:
    bool c_b = false;
    // 子类和基类 同名成员变量 ok
    short s_short = 212;

    void virtual_f() override { printf("child %s\n", __func__); }
};// 24(基类) + 1(c_b) + [1](填充) + 2(s_short) = 28 +[4](填充) = 32
```
Base基类内存布局
| 字节偏移  | 0-7 |  8-9  | 10-15  | 16-23 | 
| -------- | ---- | ---- | ---- | ---- | 
| 变量     | 指向虚函数表的指针 | s_short | 填充 | s_pc |

Child扩展类对象内存布局
| 字节偏移  | 0-23 | 24  | 25  | 26-27 | 28-31  |
| -------- | ---- | ---- | ---- | --- | ---- | 
| 变量     | Base基类 | c_b | 填充 | s_short | 填充 |

每个有虚函数的*类*(Base，Child)有自己的虚函数表，所有对象共享虚函数表，调用类非静态方法时隐式传入指向类对象的this指针。没有复写基类虚方法时，子类和基类虚函数表内容相同(只是内容相同，子/基类有自己的虚函数表)，复写了某个虚方法时，修改对应虚函数表指向对应方法。

> - 不同编译器内存布局可能不一样
> - 虚函数表的前一个指针既`void **vtable = *(void ***) &c; auto *pTypeInfo = static_cast<std::type_info *>(vtable[-1]);
`，指向的是`std::type_info*`，如果有虚函数并且编译时没有禁用`-fno-rtti`的话。

## 内存段

### 运行时内存段
运行时将虚拟内存按照逻辑功能分为一段一段的，以方便管理。比如：代码段(.text)存放编译后方法的二进制指令，只读防止代码注入。编译后的可执行文件，动态，静态库也是分段存储的(文件内存段)，在运行时按照分段加载到内存中。

| 地址  | 段 |  名称  | 存储数据  | 权限 | 说明 | 
| ---- | ---- | ---- | ---- | ---- | ---- |
| 0x0  |    |       |          |    |  程序头，系统信息  |
|0x00400000 |.text  | 代码段 | 方法(main方法 全局方法 类方法 GOT)编译后可执行的二进制指令 | 读，执行 |  共享库的代码段多个进程共享 |
|           |.rodat | 只读数据| 常量，虚函数表，类信息 |                                | 读 |
| 0x00600000 |.data  | 数据段 | 初始化的全局变量，静态变量 |                             |读写 |
| 0x00610000 |.bss |   bss段 |   未初始化的全局变量，静态变量                           | 读写 |    初始化全0的，编译器可能优化到bss段 | 
| 0x02468000 | heap |   堆 |      动态分配的内存，手动管理                            | 读写 |    可能产生内存碎片 | 
|           | mmap | 映射区 |  动态库(每个共享库，独立的段)，文件，匿名映射              | 多个权限 |   多个进程共享相同物理页(缺页中断) |         
| 0x7ffffffde000 | stack | 栈| 局部变量，线程栈，自动管理 |                           | 可读写 | 


**代码段：** 存储编译后方法的二进制执行。在编译后方法的地址就确定了，有两种情况，相对地址(位置无关)和绝对地址(位置无关)。
1. 位置有关代码，编译后方法地址，就是运行时方法量地址，代码段必须加载到指定内存位置。
2. 位置无关代码(PIC)，编译后方法地址是基于代码段地址的偏移量。代码段可以加载到任意内存位置。
   
> - 位置无关代码(PIC)，运行时相对地址计算，所以比绝对地址，直接调用要慢一点，但是可以防止内存攻击。默认编译为位置无关代码(PIC)。
> - 动态库是运行时映射到内存中，编译时还不知道地址，每个进程共享映射到不同的内存位置。所以动态库是没法编译成位置相关代码的。

调用非虚方法时，通过绝对地址或者相对地址(代码段基地址+偏移量)，找到对应方法。调用虚方法时，先访问对象的虚函数表，在通过虚函数表找到对应方法。

**数据段：** 存储初始化的全局变量，静态变量。记录变量，类型，初始值。初始值可能非常大，比如：`int arr[1024 * 1024 * 10] = {9, 4, 2};` 40M，意味着数据段只少要存储40M的数据，可执文件大小40M起。在运行加载时，分配内存读取变量值赋值给变量。
```shell
# 初始化的全局变量 int arr[1024 * 1024 * 10] = {9, 4, 2 };
➜ size main_seg                    
   text    data     bss     dec     hex filename
    173 41943048              0 41943221        28000b5 main_seg

➜ ls -lh main_seg
-rwxr-xr-x@ 1 tys  staff    40M Nov 25 19:34 main_seg
```

**bss段：** 存储未初始化的全局变量，静态变量。记录变量，类型，大小。由于只是记录大小，没有实际初始值，可执行文件小了。在运行加载时，分配内存变量值设置为0。
```shell
# 未初始化的全局变量 int arr[1024 * 1024 * 10];
➜ size main_seg                    
   text    data     bss     dec     hex filename
    173       8 41943040        41943221        28000b5 main_seg

➜ ls -lh main_seg
-rwxr-xr-x@ 1 tys  staff   8.3K Nov 25 19:43 main_seg
``` 

**堆：** 动态分配的内存，手动管理。所有线程共享(除线程本地变量) new/delete malloc/free，分配释放不同大小内存，可能造成内存碎片化。

**映射区：** 内存映射(mmap)，动态库，文件，匿名映射。缺页中断加载数据(访问到未加载的页时，从磁盘加载数据)，多个进程共享同一个物理页。映射的每个动态库，有自己独立的段。

**栈：** 线程栈，自动管理。每个线程自己独立的栈空间(8M)，生命周期固定，过深的递归调用造成栈溢出。存储局部变量，方法参数，返回地址。

```shell
# 栈空间大小查看
➜ ulimit -s
8192
```

堆，栈对比：
- 生命周期：栈，随线程的创建而创建，线程退出而结束。堆，需要手动创建和回收。
- 作用范围：栈，每个线程独立的。堆，线程之间共享，多线程之间竞争需要加锁。
- 大小：栈，单个栈大小固定，每个线程都预留8M虚拟空间，所有加起来才是总栈大小。堆，非常大，和虚拟地址空间大小相关。
- 内存创建回收：栈，栈中内存空间的创建和回收只是栈指针的移动，速度非常快。堆，堆中空间的创建回收，涉及系统调用内存管理(查找合适大小的内存空间，碎片的整理合并)。
- 读写速度：栈，内存分配通常连续的，更容易被cpu缓存命中。堆，访问是不确定的，可能导致更多缓存未命中。

> cpu缓存命中：cpu并不是每次从内存中读取它需要的字节数，而是按缓存行大小读取(64k)。如果要访问的数据在缓存行中，就不需要从内存中在读取数据。cpu缓存命中比从内存中加载快得多。缓存行是CPU与内存之间数据传输的基本单位。

### 栈上内存分配：
通过栈指针rsp(Register Stack Pointer)的移动，在栈上创建回收空间。

RSP(Register Stack Pointer)寄存器：栈顶指针(始终指向栈顶)，x86架构栈顶(最后放入数据位置)是低地址。随着入栈(push)自动减小，出栈(pop)自动增加。
RBP(Register Base Pointer)寄存器：帧指针，指向函数栈帧基地址。通过偏移访问参数，局部变量。

```cpp
void test_fun(int i, const char *string) {
    // 参数
    // 4 +[4] + 8 = 16
    // 局部变量
    // 16 + 1 = 17 + [15] = 32 // 最终栈16字节对齐
    bool f = true;
    printf("%d \n", i);
}
```

```shell
    ## test_fun方法对应汇编代码 x86架构
    pushq	%rbp    ## 当前方法栈基地址 入栈，rsp自动-8
    movq	%rsp, %rbp  ##  rbp = rsp，rbp指向新的栈基地址
    subq	$32, %rsp   ## rsp -= 32 栈上分配32字节
    movl	%edi, -4(%rbp) ## 第一个int参数存在 -4(%rbp) rbp-4的位置 
    movq	%rsi, -16(%rbp) ## 第二个指针参数存在 -16(%rbp)，依次顺序存储的话应该是-12(%rbp)，所以这里填充了4字节
    movb	$1, -17(%rbp) ## 局部变量 1写入-17(%rbp)
    ...
    addq	$32, %rsp   ## rsp +=32 栈上内存回收
    popq	%rbp    ## 出栈
    retq
```
进入方法后，通过栈指针(rsp)的移动，在栈上分配空间。存储方法参数和局部变量到分配的空间上。


## 库

### 静态库

链接时：
1. 合并静态库的段，到可执行文件对应段。只会合并用到的数据，代码。而不是整个静态库。比如：静态库中被引用的代码段，合并到目标文件的代码段。
2. 符号解析和重定位。比如，引用静态库中的方法/变量，编译时不知道地址，只是一个占位符。在合并到可执行文件后知道了方法的地址，会将原来占位符的地址填上实际地址。

引用的代码和数据被合并到了可执行文件，所以可执行文件会变大。但是不用指定运行时环境，同时可能有更多的方法内联。

运行时：
应为是合并到可执行文件，所以引用静态库中的方法、变量和引用本地方法、变量是一样的。编译时知道方法，变量的地址(偏移量)，运行时通过基地址 + 偏移量找到对应方法，变量。比如：编译时知道某个方法相对于代码段的偏移量，运行时代码被加载到了内存xx基地址， 基地址 + 偏移量 = 运行时方法的实际地址。ß

### 动态库

链接时




对于动态库，在运行时 触发缺页中断时 从对应的动态库中加载到内存